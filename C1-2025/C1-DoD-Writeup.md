This was the second [Correlation One CTF](https://www.credential.net/691a7a3a-c456-4ea4-85b8-3b6bd17617c6#acc.BvlkGUNp) I participated in, and the second CTF hosted by Correlation One. This year, the competition was free to share write-ups for, and it's been a while since I've done a write-up. I placed 83rd of 4,313 people participating, and 6,000 accepted applicants. I completed 13 of the 19 challenges, and was very happy with my performance. I have selected a handful of my favorite challenges to review. Unfortunately, I was too busy competing to collect screenshots, and am providing the writeup from memory.

1. I'm going to start off right out of the gate with something I've encountered more, recently in CTFs, and it's a vulnerability that I have been waiting to find since the beginning of my journey in information security. JWTs are a very common form of authentication and authorization on a plethora of web applications. These are cookies that are stored in base64, and come in three parts; the JWT header, the payload, and the signature, and they are formatted as a JSON object. The three parts are separated by a '.' character. They share some design similarity and concept to network packets, but that's not relevant to the exploitation, here. Not directly, at least. In any case, the header of the JWT holds two important pieces of information: a boilerplate piece of data that tells us what the token is (a JWT), and a piece of data that tells us what hashing algorithm we used to sign the token. The header looks something like this when decoded: 
	
	{"alg":"HS256","typ":"JWT"}
	
	The second part of a JWT is the payload, and generally contains information about a user or their session, but that's convention, and not required. The decoded payload would look something like this:

	{"sub":"1234567890","name":"John Doe","iat":9876543210}

	Data will vary based on application. The final part is the signature. This is a hash based on a secret and the data in the previous parts of the JWT. If the signature doesn't match what the application hashes, the application should generally disallow the token. 
	
	A good tool to use is a [JWT debugger](https://jwt.io/). Traditionally, I've used the first link there, but [this debugger](https://token.dev/) lets you play with more of the data. But one thing that I noticed when I put the token into the debugger was that I was getting a warning that the signature didn't match. I'm not sure if this was related to the challenge or not, but since I saw that warning, I figured I'd just try changing one of the fields in the payload to give me the access I needed. I didn't modify the signature to match the new data, and in hindsight, that may have been something interesting to try, but being that this was a timed event, I moved on to trying the none algorithm. When a website is misconfigured or programmed improperly, you can tell the JWT parser to use the none algorithm. You do this in the header, and it looks like this:
	
	{"alg": "none","typ": "JWT"}
	
	Because base64 encoding is case-sensitive, make sure you avoid doing what I did at first, and ensure that the first 'n' in 'none' is lower-case. It'll save you some time. When I had the correct case for the token, I re-encoded it, reassembled my JWT, and replaced the value in the storage tab for the cookie in Mozilla, and I was able to obtain the flag.
	
2. A more simple web exploitation came just before the JWT exploitation from above that involved exploiting Insecure Data Object Reference (IDOR). For this challenge, we were given credentials to a website to give us access to a themed profile for the challenge. Once inside, checking the cookies didn't reveal anything out of the ordinary, and given that we already had valid credentials, I didn't think we needed to do anything along those lines. There may have been something in the description that made me think it could be an IDOR challenge, but the biggest hint was to examine the URL of the page. IDOR happens when an authenticated user accesses a page that contains some identifying data in the URL, either directly or as a parameter. The user then edits the relevant part of the URL, and the page they are trying to navigate to doesn't check for proper authorization. An example URL that might be vulnerable could be https://example.com/user/123/profile or https://example.com/user/profile?id=123 . By editing the '123' portion of the URL, an authenticated user would be able to access data they should not be able to on a vulnerable website. And, as luck would have it, this was the case here. There were about 20 or so users I iterated over, but none of them ended up having a flag. They were all in sequence, and brute-forcing the infrastructure of the platform was discouraged. The point being that we weren't supposed to be overburdening the system. I looked a little closer at the challenge prompt, and it mentioned a "leet hacker". It may have even been "1337 h4ck0r", but when I re-read that part, I figured I'd plug in 1337 into the URL, and I was able to find my flag. That one seemed a little dirty, because the other IDs were all between about 1-20, and brute-forcing was disallowed, but I suppose they had to make it at least a little challenging. 

3. The next challenge I am going to go over was an open source intelligence (OSINT) challenge, and was on the hardest one in that category. We were given two images of a world leader who was inspecting a new project in their country. One from outside on the street, and one from inside of the building. The first image, of the head of state walking down the road had the most valuable insight into where in the world they were. Doing a reverse image search was able to reveal the city and neighborhood that they were in, which was very helpful. Unfortunately, the sattelite imagery for this area was not up to date, and one of the defining features of this picture, an eight or so story tall pedestrian bridge across the street, was not present in either of the map services I used for this challenge. That being said, the image was very publicized on certain social media pages. In particular, there was a Reddit page that had even more images of the area that were more up to date. So I started to scour through those images for any more unique identifiers. There were about 16, maybe 18 images, and toward the end, I noticed that in the background of one of the city skylines, there was a sort of blue to teal coloring in the background before the road turned to the right, and then back to the left far off in the distance. The color was on either side of the road. Some of the other pictures had some relatively unique paired buildings in them; tall and domed. A number of the pictures also had the main road go through them, which was very straight along the skyscraper section, and there was a roundabout built into a highly visible portion. It ended up being the teal spot with the road that helped me find the area as I was spiraling out from the middle of the neighborhood I was casing through the sattelite images, and the pairs of rounded-top buildings confirmed it when I found the road I needed. Turns out, what I had assumed was a dyed lake was actuallt a set of greenhouses, but I had found the area. 

	Now, the next parts were when things got interestng. I was going to have to figure out where the building from the second photo was, using latitude and longitute, up to the third decimal place, within 500m. And I was going to have to do this on a map that didn't have the building on it. One thing that helped me was the bridge from the first photo. I could see it in a few of the pictures I'd found on the Reddit post, and it gave me a decent frame of reference for the scale of the new construction. That being said, since the second photo was from inside of the target building, it was going to be difficult to say where the building was just from the second photograph. However, one thing I noticed at this point was that the building the second picture was from had some pretty thick 'X' shapes in the windows. That had to be relatively unique, I figured. So now I just had to look for those shapes in the buildings from the Reddit photos. Given that the sky was not visible from the building, I had to wager that it was not at the top of any of the buildngs, so I started my search from the bottom half of the buildings in the pictures. Eventually, I saw something on the ground floor that looked like it could be it -- 'X' shapes in the windows. Because the picture had the pedestrian bridge in the photo where I found the target, I was able to reference some of the other pictures in the Reddit set for scale, and roughly gauge which block it was on for the map. Now, I only had 50 chances to guess the correct coordinates, but that was when I remembered that a 500m raduis is 1km, and that's good odds. Using the scale measurement on the map, I chose the coordinates I figured would be the right block, put it in, and scored the flag for the challenge. I'm particularly proud of this one because I know a lot of folks were talking about it in the Slack channel that was set up for this event, and I enjoy the OSINT. It meshes well with my social engineering background. But I'm also fond of getting around access control, and IAM in general. [See one of my other hobbies.](https://en.wikipedia.org/wiki/Locksport)
	
4. This next challenge is one of those things that's probably more common in CTFs than in the wild, at least for every-day security. We were given an audio file, and were expected to extract the flag. There was already a metadata challenge. More than one, actually, and this one was valued higher than those, so I figured [exiftool](https://exiftool.org/) was not going to get us the flag this time. When I opened the file, and turned up my volume, I heard something that should be familiar to many people who can hear, and it was the dial tone multi-frequency (DMTF) sounds from dialing a phone. I only lucked into knowing that this was DTMF signalling because of an application I have on a device I own that references DTMF in the title, and I looked it up once. But that curiosity served me well here, because I knew I had to decode the DTMF codes to get the flag. The first tool I tried was [this tool](https://nhollmann.github.io/DTMF-Tool/) that I found (If you are unfamiliar with DTMF tones, and would like to produce semi-annoying sounds, you can use the tool to play them). It at least got me on the right path, because I could see that it was only 1 and 0 being played on the recording, but when I went to decode the binary into a string, I didn't get anything meaningful. That made sense, because it wasn't a direct pipeline from the file to the decoder, and ambient noise, no matter how small, would interfere. I ended up turning to an LLM to help me find and choose a tool, and ended up using multimon-ng. To get the initial output, I ran 'multimon-ng -t wav -a DTMF radio.wav > output.txt' but got an error message that prompted me to install sox. After installing this, I got a file that needed some cleaning, but after I some awk and tr with help from the LLM, I arrived at a binary output that decoded to a flag, and was able to solve the challenge. 

5. This next challenge involved discovering and interacting with a mystery service on a given IP. Aside from the IP, we knew that the port was somewhere between 5,000 and 10,000. My go-to tool for port scanning is nmap, though I have used a couple others in my career. So, to discover the port, I ran 'sudo nmap -p5000-10000 IP_REDACTED -sS -sV -vv'. The sudo is key here to run the -sS, not that I necessarily needed it, but the 'stealth' flag can help evade firewalls, and you can't use it if you're not running it as a super user or root. -sV helped check what service was running once the port was discovered. -p5000-10000 just describes the port range for nmap. And -vv is two levels of verbosity. I like to have user feedback, and -v just isn't enough for me, especially since -sS and -sV can take some time. In any case, we found the port at 8774, and it appeared to be running some kind of streaming service. 

	Knowing that we had a streaming type service at the other end, I figured I'd give VLC a try at opening the stream, since I know you can access IP cams that way, and I thought that was what this might be. That being said, it wasn't just that easy. This is one of the challenges where I only solved toward the end of the event, when I was willing to spend points on hints. Admittedly, I did game it, a little. There were a few challenges where I could have spent the points on hints, but I wanted to stay in the top 100. To that end, I only spent points on the challenges where at least 100 people had solved it already, and where I knew I'd found imporant details that would make the hints worthwhile. Essentially, this would equate to asking a coworker on the job for help, which I've done more than a few times. Which is why the hints can be very helpful in a solo task like this. The hint I ended up revealing directed me to try enumerating the port by brute-forcing possible paths and protocols, suggesting using ffprobe, which was part of a package I'd downloaded earlier in the competition to solve one of the easier file metadata challenges. Prior to the competition, we were told to avoid performing any attacks that could take down the system, so I figured I'd try a manual process to enumerate the paths, going in with a pretty good feeling that this would be an rtsp protocol, since it was a streaming service. The command I ended up using was 'ffprobe -i "rtsp://IPADDR:8774/PATH"' where PATH varied from command to command. I started with no path, and then tried /live, /stream, /video, and a few others. Most of them were erroring out, but /stream didn't give me anything back. So after playing a quick round of "which one of these is not like the other", and consulting with the LLM, I came to try 'ffprobe -v error -show_streams -i "rtsp://IPADDR:8774/stream"'. This command would give me a bit more information than the original, and when I felt good enough, I ran 'ffplay - "rtsp://IPADD:8774/stream"', which opened up a window with a very clearly AI generated video, looping, that would show the flag from time to time. After a few loops, I was able to get the flag, and move on to the next challenge. 
	
6. The final challenge I'm deciding to write about, and the final challenge I ended up solving was a pretty neat exploit that I had to learn about on the fly during the competition. For this challenge, a website was being hosted on a domain, with the challenge description that there might be a way to gain access to an internal version of the website. Not really sure how to do this, I started messing around wih the website, to see what I could find. There was a warning for the certificate when I first accessed the page, and thought nothing of it, accepting the risk and continuing. There didn't seem to be anything in the cookies or the requests that I could find. Eventually, though, recalling the certificate warning, I ended up checking it out to see what I could find. When I did, I discovered that there was a second domain in the cert. I'd encountered something like this in one of the very, very first CTFs I ever did, and it involved the hosts file. So I tried a few entries to redirect from the public domain to the second domain, but because I'd only ever run into it once, I needed to burn another hint on this one. 

	What the hint ended up suggesting was not to use the hosts file, but rather to perform an HTTP Host header attack. Since I had already discovered the domain I was meant to be headed toward, I simply searched for the attack online, and found [PortSwigger's article](https://portswigger.net/web-security/host-header) which explained the premise behind the attack, and [the attack itself](https://portswigger.net/web-security/host-header#what-is-an-http-host-header-attack). Being that this was on PortSwigger, I had a feeling I'd be using [BurpSuite](https://portswigger.net/burp/communitydownload). I did try to do this with Mozilla's developer tools by editing and resending a request, but Mozilla didn't let me change the host value, so it didn't work. BurpSuite did let me do that, which was highly important because the key to the attack was to capture the request sent to the public domain in the host field, and edit it to point to the private domain. By capturing the response to this request, I was able to browse the page, and find the flag. 
	
I enjoyed this competition, thoroughly, and I was satisfied with how I performed. Of course, I am always looking to improve, so I'm not going to stop here. Being able to improve as much as I did in only one year excites me because of what it means for the future. I've been using labs from [PentesterLab](https://pentesterlab.com/) these days, as part of a voucher I won from [MetaCTF](https://metactf.com/), whose competitions I participate in monthly, and who have been letting my team and me demo their [on-demand labs](https://metactf.com/products/on-demand-labs/) for a month. It's been a blast seeing how we stack up against each other, and being able to teach and learn from one another. As things have settled down in my life, I'm looking forward to getting in more training, and working on more of my personal projcets. Until next time!
